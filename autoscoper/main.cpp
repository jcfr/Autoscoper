// ----------------------------------
// Copyright (c) 2011, Brown University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// (1) Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// (2) Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// (3) Neither the name of Brown University nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY BROWN UNIVERSITY “AS IS” WITH NO
// WARRANTIES OR REPRESENTATIONS OF ANY KIND WHATSOEVER EITHER EXPRESS OR
// IMPLIED, INCLUDING WITHOUT LIMITATION ANY WARRANTY OF DESIGN OR
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, EACH OF WHICH ARE
// SPECIFICALLY DISCLAIMED, NOR ANY WARRANTY OR REPRESENTATIONS THAT THE
// SOFTWARE IS ERROR FREE OR THAT THE SOFTWARE WILL NOT INFRINGE ANY
// PATENT, COPYRIGHT, TRADEMARK, OR OTHER THIRD PARTY PROPRIETARY RIGHTS.
// IN NO EVENT SHALL BROWN UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
// OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY OR CAUSE OF ACTION, WHETHER IN CONTRACT,
// STRICT LIABILITY, TORT, NEGLIGENCE OR OTHERWISE, ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. ANY RECIPIENT OR USER OF THIS SOFTWARE ACKNOWLEDGES THE
// FOREGOING, AND ACCEPTS ALL RISKS AND LIABILITIES THAT MAY ARISE FROM
// THEIR USE OF THE SOFTWARE.
// ---------------------------------

/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

//#include <execinfo.h>
#include <cstdlib>
#include <stdexcept>
#include <iostream>

#include <gtk/gtk.h>
#include <gtk/gtkgl.h>
#include <GL/glx.h>

#include "interface.hpp"
#include "support.hpp"

/*
void terminate();

namespace {
    static const bool SET_TERMINATE =
        std::set_terminate(terminate);
}
*/

int main(int argc, char *argv[])
{
    GtkWidget *window;
    GtkWidget *drawingarea1;
    GtkWidget *drawingarea2;
    GtkWidget *graph_drawingarea;

    GdkGLConfig *glconfig = NULL;
	//GdkGLContext *glcontext = 0;

	g_thread_init(NULL);
	gdk_threads_init();
	gdk_threads_enter();

    gtk_set_locale();
    gtk_init(&argc, &argv);

    // Initialize gtkglext
    gtk_gl_init(&argc, &argv);

    // Configure opengl
    glconfig = gdk_gl_config_new_by_mode(GdkGLConfigMode(GDK_GL_MODE_RGBA |
                                                       GDK_GL_MODE_DEPTH |
                                                       GDK_GL_MODE_DOUBLE));

    if (glconfig == NULL) {
        g_print("*** Unable to configure OpenGL.\n");
        exit(1);
    }

    // The following code was added by Glade to create one of each component
    // (except popup menus), just so that you see something after building
    // the project. Delete any components that you don't want shown initially.
    window = create_xromm_markerless_tracking_window ();

    gtk_widget_add_events(window,
                        GDK_KEY_PRESS_MASK|
                        GDK_KEY_RELEASE_MASK);


    drawingarea1 = lookup_widget(window,"xromm_markerless_tracking_drawingarea1");
    drawingarea2 = lookup_widget(window,"xromm_markerless_tracking_drawingarea2");
    graph_drawingarea = lookup_widget(window,"xromm_markerless_tracking_graph_drawingarea");

    // Add opengl capabilities to the drawing area.
    gtk_widget_set_gl_capability(drawingarea1,
                               glconfig,
                               0,//glcontext,
                               TRUE,
                               GDK_GL_RGBA_TYPE);
    gtk_widget_set_gl_capability(drawingarea2,
                               glconfig,
                               0,//glcontext,
                               TRUE,
                               GDK_GL_RGBA_TYPE);
    gtk_widget_set_gl_capability(graph_drawingarea,
                               glconfig,
                               0,//glcontext,
                               TRUE,
                               GDK_GL_RGBA_TYPE);

    gtk_widget_add_events(drawingarea1,
                        GDK_BUTTON_PRESS_MASK |
                        GDK_BUTTON_RELEASE_MASK |
                        GDK_BUTTON_MOTION_MASK |
                        GDK_POINTER_MOTION_MASK);
    gtk_widget_add_events(drawingarea2,
                        GDK_BUTTON_PRESS_MASK |
                        GDK_BUTTON_RELEASE_MASK |
                        GDK_BUTTON_MOTION_MASK |
                        GDK_POINTER_MOTION_MASK);
    gtk_widget_add_events(graph_drawingarea,
                        GDK_BUTTON_PRESS_MASK |
                        GDK_BUTTON_RELEASE_MASK |
                        GDK_BUTTON_MOTION_MASK |
                        GDK_POINTER_MOTION_MASK);

    // Display the main window
    gtk_widget_show (window);

    gtk_main();

	gdk_threads_leave();

    return EXIT_SUCCESS;
}
/*
void terminate()
{
    static bool tried_throw = false;
    try {
        if (!tried_throw++) {
            throw;
        }
    }
    catch (const std::exception& e) {
        std::cerr << __FUNCTION__ << " caught unhandled exception. what(): "
                  << e.what() << std::endl;
    }
    catch (...) {
        std::cerr << __FUNCTION__ << " caught unknown/unhandled exception."
                  << std::endl;
    }

    void* array[50];
    int size = backtrace(array,50);

    std::cerr << __FUNCTION__ << " backtrace returned " << size << " frames\n" << std::endl;

    char** messages = backtrace_symbols(array,size);
    for (int i = 0; i < size && messages != NULL; ++i) {
        std::cerr << "[bt]: (" << i << ") " << messages[i] << std::endl;
    }
    std::cerr << std::endl;

    free(messages);

    abort();
}
*/
